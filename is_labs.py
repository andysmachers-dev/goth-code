# -*- coding: utf-8 -*-
"""is labs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qh2xLzSJEK1fdzpFKa6yhKmOcRj6lr8B
"""
#__________________________________________LAB 1_________________________________________
def caesar_cipher(text, key, mode):
    result = ""
    shift = key % 26
    if mode == 'd':
        shift = -shift
    for char in text:
        if char.isalpha():
            start = ord('A') if char.isupper() else ord('a')
            result += chr((ord(char) - start + shift) % 26 + start)
        else:
            result += char
    return result

text = input("Caesar Cipher - Enter message: ")
key = int(input("Enter shift key(integer): "))
mode = input("Encrypt (e) or Decrypt (d)? ")
print("Result:", caesar_cipher(text, key, mode))


#__________________________________________LAB 2_________________________________________
def rail_fence_encrypt(text, num_rails):
    rails = ['' for _ in range(num_rails)]
    idx, direction = 0, 1
    for char in text:
        rails[idx] += char
        idx += direction
        if idx == num_rails - 1 or idx == 0:
            direction *= -1
    return ''.join(rails)

def rail_fence_decrypt(cipher, num_rails):
    rail_lens = [0] * num_rails
    idx, direction = 0, 1
    for _ in cipher:
        rail_lens[idx] += 1
        idx += direction
        if idx == num_rails - 1 or idx == 0:
            direction *= -1
    rails = []
    i = 0
    for r in rail_lens:
        rails.append(cipher[i:i + r])
        i += r
    result = []
    idxs = [0] * num_rails
    idx, direction = 0, 1
    for _ in cipher:
        result.append(rails[idx][idxs[idx]])
        idxs[idx] += 1
        idx += direction
        if idx == num_rails - 1 or idx == 0:
            direction *= -1
    return ''.join(result)

text = input("Rail Fence Cipher - Enter message: ")
rails = int(input("Enter number of rails: "))
mode = input("Encrypt (e) or Decrypt (d)? ")
if mode == 'e':
    print("Encrypted:", rail_fence_encrypt(text, rails))
else:
    print("Decrypted:", rail_fence_decrypt(text, rails))


#________________________________________LAB 3_____________________________________
def prepare_text(text):
    text = text.replace("J", "I").upper().replace(" ", "")
    prepared = ""
    i = 0
    while i < len(text):
        char = text[i]
        if i+1 < len(text) and text[i] == text[i+1]:
            prepared += text[i] + 'X'
            i += 1
        else:
            if i+1 < len(text):
                prepared += text[i] + text[i+1]
                i += 2
            else:
                prepared += text[i] + 'X'
                i += 1
    return prepared

def create_matrix(key):
    matrix = []
    key = key.upper().replace("J", "I")
    used = set()
    for char in key:
        if char not in used and char.isalpha():
            used.add(char)
            matrix.append(char)
    for char in "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if char not in used:
            matrix.append(char)
    return [matrix[i*5:(i+1)*5] for i in range(5)]

def find_pos(matrix, ch):
    for r, row in enumerate(matrix):
        if ch in row:
            return r, row.index(ch)
    return None

def playfair_encrypt(text, matrix):
    prepared = prepare_text(text)
    result = ""
    for i in range(0, len(prepared), 2):
        a, b = prepared[i], prepared[i+1]
        ra, ca = find_pos(matrix, a)
        rb, cb = find_pos(matrix, b)
        if ra == rb:
            result += matrix[ra][(ca+1)%5] + matrix[rb][(cb+1)%5]
        elif ca == cb:
            result += matrix[(ra+1)%5][ca] + matrix[(rb+1)%5][cb]
        else:
            result += matrix[ra][cb] + matrix[rb][ca]
    return result

def playfair_decrypt(cipher, matrix):
    result = ""
    for i in range(0, len(cipher), 2):
        a, b = cipher[i], cipher[i+1]
        ra, ca = find_pos(matrix, a)
        rb, cb = find_pos(matrix, b)
        if ra == rb:
            result += matrix[ra][(ca-1)%5] + matrix[rb][(cb-1)%5]
        elif ca == cb:
            result += matrix[(ra-1)%5][ca] + matrix[(rb-1)%5][cb]
        else:
            result += matrix[ra][cb] + matrix[rb][ca]
    return result

key = input("Playfair Cipher - Enter key: ")
matrix = create_matrix(key)
text = input("Enter message: ")
mode = input("Encrypt (e) or Decrypt (d)? ")
if mode == 'e':
    print("Encrypted:", playfair_encrypt(text, matrix))
else:
    print("Decrypted:", playfair_decrypt(text, matrix))
#

#_____________________________________________________LAB 4____________________________________
import rsa, base64

(pubkey, privkey) = rsa.newkeys(512)
mode = input("RSA - Encrypt (e) or Decrypt (d)? ")
if mode == 'e':
    text = input("Enter message: ")
    enc = rsa.encrypt(text.encode(), pubkey)
    print("Encrypted:", base64.b64encode(enc).decode())
else:
    cipher = input("Enter base64 cipher: ")
    dec = rsa.decrypt(base64.b64decode(cipher.encode()), privkey)
    print("Decrypted:", dec.decode())


#___________________________________________LAB 5__________________________________
!pip install pycryptodome

from Crypto.Cipher import DES
import base64

def pad(s):
    return s + (8 - len(s) % 8) * ' '

key = input("DES - Enter 8-byte key: ")
cipher = DES.new(key.encode('utf-8'), DES.MODE_ECB)
mode = input("Encrypt (e) or Decrypt (d)? ")
if mode == 'e':
    text = input("Enter message: ")
    enc_bytes = cipher.encrypt(pad(text).encode('utf-8'))
    print("Encrypted:", base64.b64encode(enc_bytes).decode())
else:
    enc_b64 = input("Enter base64 cipher: ")
    dec_bytes = cipher.decrypt(base64.b64decode(enc_b64.encode()))
    print("Decrypted:", dec_bytes.decode().rstrip())


#_________________________________________LAB 6________________________________
import hashlib

text = input("Hashing - Enter message: ")
md5 = hashlib.md5(text.encode()).hexdigest()
sha1 = hashlib.sha1(text.encode()).hexdigest()
sha256 = hashlib.sha256(text.encode()).hexdigest()
print(f"MD5: {md5}\nSHA-1: {sha1}\nSHA-256: {sha256}")

