# -*- coding: utf-8 -*-
"""quantum_machine_learing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rlokfLwPH3Ayyl2bW0ov9NRnagAsnexT

Prepare a single qubit in the zero state and apply a Hadamard gate.
Describe the final behaviour of the qubit and its measurement outcomes.
"""

!pip install qiskit qiskit_aer pylatexenc qiskit[visualization] matplotlib

import matplotlib.pyplot as plt
import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from qiskit.quantum_info import Statevector
import pylatexenc

class QuantumEngine:
    def __init__(self):
        self.simulator = AerSimulator()

    def generate_random_number(self, min_val, max_val):
        """
        Generates a random integer between min_val and max_val using Quantum Superposition.
        """
        range_span = max_val - min_val
        num_qubits = range_span.bit_length()

        qc = QuantumCircuit(num_qubits, num_qubits)

        qc.h(range(num_qubits))

        qc.measure(range(num_qubits), range(num_qubits))

        compiled_circuit = transpile(qc, self.simulator)
        job = self.simulator.run(compiled_circuit, shots=1)
        result = job.result()
        counts = result.get_counts()

        binary_string = list(counts.keys())[0]
        random_int = int(binary_string, 2)

        final_number = min_val + (random_int % (range_span + 1))

        return final_number, qc

    def create_bell_pair(self):
        """
        Creates a Bell State (Entanglement) between two qubits:
        |Psi> = (|00> + |11>) / sqrt(2)
        """
        qc = QuantumCircuit(2, 2)

        qc.h(0)

        qc.cx(0, 1)

        qc.save_statevector()

        qc.measure([0, 1], [0, 1])

        return qc

engine = QuantumEngine()

low = 0
high = 100

random_num, rng_circuit = engine.generate_random_number(low, high)

print(f"Generated Quantum Random Number: {random_num}")

print("Circuit Diagram:")
rng_circuit.draw('text')

bell_circuit = engine.create_bell_pair()

compiled_circuit = transpile(bell_circuit, engine.simulator)
job = engine.simulator.run(compiled_circuit, shots=1000)
result = job.result()
counts = result.get_counts()

state = result.get_statevector(bell_circuit)

print("Measurement Counts (should be ~50/50 split between 00 and 11):")
print(counts)

plot_histogram(counts, title="Bell State Measurement Outcomes")

def experiment():
    qc = QuantumCircuit(1, 1)

    qc.h(0)

    qc.measure(0, 0)

    simulator = AerSimulator()
    compiled_circuit = transpile(qc, simulator)
    job = simulator.run(compiled_circuit, shots=1000)
    result = job.result()
    counts = result.get_counts()

    return qc, counts

circuit, counts = experiment()

print("Circuit Diagram:")
print(circuit.draw('text'))

print(f"Measurement Results from 1000 shots: {counts}")

plot_histogram(counts, title="Superposition Measurement Outcomes (Approaching 50/50)")